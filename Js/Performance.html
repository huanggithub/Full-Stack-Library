<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>性能优化 | Full-Stack Library</title>
    <meta name="description" content="前端图书馆">
    <link rel="icon" href="/Full-Stack-Library/favicon.ico">
    
    <link rel="preload" href="/Full-Stack-Library/assets/css/0.styles.06ff079b.css" as="style"><link rel="preload" href="/Full-Stack-Library/assets/js/app.4ce4532c.js" as="script"><link rel="preload" href="/Full-Stack-Library/assets/js/15.ed466076.js" as="script"><link rel="prefetch" href="/Full-Stack-Library/assets/js/10.42bf570e.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/11.02a7cdf7.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/12.24aac5b1.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/13.f05d0c07.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/14.3eeee341.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/16.b73ff0c5.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/17.409ec8cb.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/18.41a5ef59.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/19.bd99bd40.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/2.6d46b3d4.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/20.847d7aa7.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/21.83973dd9.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/22.0a98a10d.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/23.62c8183e.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/24.959eafea.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/25.305737ef.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/26.26c6b30a.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/27.aa255f2d.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/28.1b44f19f.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/29.d0567573.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/3.a1bfc395.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/30.d639d762.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/4.f401f2bf.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/5.3587192b.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/6.e717810c.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/7.55823cc8.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/8.68d17432.js"><link rel="prefetch" href="/Full-Stack-Library/assets/js/9.1bde4162.js">
    <link rel="stylesheet" href="/Full-Stack-Library/assets/css/0.styles.06ff079b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Full-Stack-Library/" class="home-link router-link-active"><!----> <span class="site-name">Full-Stack Library</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Full-Stack-Library/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">基础进阶</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Js/" class="nav-link router-link-active">深入 JavaScript</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/CSS/" class="nav-link">深入 CSS</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">主流框架</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Vue/" class="nav-link">Vue专栏</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/React/" class="nav-link">React专栏</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Applets/" class="nav-link">小程序专栏</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Wechat/" class="nav-link">微信公众号</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Hybrid/" class="nav-link">Hybrid开发专栏</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">移动端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Flutter/" class="nav-link">Flutter</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/iOS/" class="nav-link">iOS原生开发</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">服务端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Algorithms/" class="nav-link">数据结构与算法</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/HTTP/" class="nav-link">HTTP详解</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Node/" class="nav-link">Node.js</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">全栈思维</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/WebSafety/" class="nav-link">Web安全</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/AutoText/" class="nav-link">自动化测试</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Blockchain/" class="nav-link">区块链</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Repository/" class="nav-link">推荐库</a></li></ul></div></div> <a href="https://github.com/ViktorWong/Full-Stack-Library" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Full-Stack-Library/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">基础进阶</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Js/" class="nav-link router-link-active">深入 JavaScript</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/CSS/" class="nav-link">深入 CSS</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">主流框架</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Vue/" class="nav-link">Vue专栏</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/React/" class="nav-link">React专栏</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Applets/" class="nav-link">小程序专栏</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Wechat/" class="nav-link">微信公众号</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Hybrid/" class="nav-link">Hybrid开发专栏</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">移动端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Flutter/" class="nav-link">Flutter</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/iOS/" class="nav-link">iOS原生开发</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">服务端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Algorithms/" class="nav-link">数据结构与算法</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/HTTP/" class="nav-link">HTTP详解</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Node/" class="nav-link">Node.js</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">全栈思维</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/WebSafety/" class="nav-link">Web安全</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/AutoText/" class="nav-link">自动化测试</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Blockchain/" class="nav-link">区块链</a></li><li class="dropdown-item"><!----> <a href="/Full-Stack-Library/Repository/" class="nav-link">推荐库</a></li></ul></div></div> <a href="https://github.com/ViktorWong/Full-Stack-Library" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav> <div class="my-ad"><img src="/Full-Stack-Library/zhifubao.png" width="48%" style="border-radius:3px;opacity:0.9;"> <img src="/Full-Stack-Library/weixin.png" width="48%" style="border-radius:3px;opacity:0.9;"> <div align="center" class="ad-mark">若你觉得很赞, 可以请我喝果汁 🍹</div></div> <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>JS 进阶</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/Full-Stack-Library/Js/" class="sidebar-link">深入 JavaScript</a></li><li><a href="/Full-Stack-Library/Js/Coding.html" class="sidebar-link">代码重构经验</a></li><li><a href="/Full-Stack-Library/Js/Performance.html" class="active sidebar-link">性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Full-Stack-Library/Js/Performance.html#网络相关" class="sidebar-link">网络相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Full-Stack-Library/Js/Performance.html#dns-预解析" class="sidebar-link">DNS 预解析</a></li><li class="sidebar-sub-header"><a href="/Full-Stack-Library/Js/Performance.html#缓存" class="sidebar-link">缓存</a></li><li class="sidebar-sub-header"><a href="/Full-Stack-Library/Js/Performance.html#使用-http-2-0" class="sidebar-link">使用 HTTP / 2.0</a></li><li class="sidebar-sub-header"><a href="/Full-Stack-Library/Js/Performance.html#预加载" class="sidebar-link">预加载</a></li><li class="sidebar-sub-header"><a href="/Full-Stack-Library/Js/Performance.html#预渲染" class="sidebar-link">预渲染</a></li></ul></li><li class="sidebar-sub-header"><a href="/Full-Stack-Library/Js/Performance.html#pwa-离线缓存" class="sidebar-link">PWA 离线缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Full-Stack-Library/Js/Performance.html#主线程" class="sidebar-link">主线程</a></li><li class="sidebar-sub-header"><a href="/Full-Stack-Library/Js/Performance.html#基于-https" class="sidebar-link">基于 HTTPS</a></li><li class="sidebar-sub-header"><a href="/Full-Stack-Library/Js/Performance.html#scope-作用域" class="sidebar-link">Scope 作用域</a></li><li class="sidebar-sub-header"><a href="/Full-Stack-Library/Js/Performance.html#生命周期" class="sidebar-link">生命周期</a></li></ul></li><li class="sidebar-sub-header"><a href="/Full-Stack-Library/Js/Performance.html#优化渲染过程" class="sidebar-link">优化渲染过程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Full-Stack-Library/Js/Performance.html#懒执行" class="sidebar-link">懒执行</a></li><li class="sidebar-sub-header"><a href="/Full-Stack-Library/Js/Performance.html#懒加载" class="sidebar-link">懒加载</a></li></ul></li><li class="sidebar-sub-header"><a href="/Full-Stack-Library/Js/Performance.html#文件优化" class="sidebar-link">文件优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Full-Stack-Library/Js/Performance.html#图片优化" class="sidebar-link">图片优化</a></li><li class="sidebar-sub-header"><a href="/Full-Stack-Library/Js/Performance.html#其他文件优化" class="sidebar-link">其他文件优化</a></li><li class="sidebar-sub-header"><a href="/Full-Stack-Library/Js/Performance.html#cdn" class="sidebar-link">CDN</a></li></ul></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="性能优化"><a href="#性能优化" aria-hidden="true" class="header-anchor">#</a> 性能优化</h1> <h2 id="网络相关"><a href="#网络相关" aria-hidden="true" class="header-anchor">#</a> 网络相关</h2> <h3 id="dns-预解析"><a href="#dns-预解析" aria-hidden="true" class="header-anchor">#</a> DNS 预解析</h3> <p>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>dns-prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>//yuchengkai.cn<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h3 id="缓存"><a href="#缓存" aria-hidden="true" class="header-anchor">#</a> 缓存</h3> <p>缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。</p> <p>通常浏览器缓存策略分为两种：强缓存和协商缓存。</p> <h4 id="强缓存"><a href="#强缓存" aria-hidden="true" class="header-anchor">#</a> 强缓存</h4> <p>实现强缓存可以通过两种响应头实现：<code>Expires</code> 和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，<code>state code</code> 为 200</p> <div class="language-js extra-class"><pre class="language-js"><code>Expires<span class="token punctuation">:</span> Wed<span class="token punctuation">,</span> <span class="token number">22</span> Oct <span class="token number">2018</span> <span class="token number">08</span><span class="token punctuation">:</span><span class="token number">41</span><span class="token punctuation">:</span><span class="token number">00</span> <span class="token constant">GMT</span>
</code></pre></div><p><code>Expires</code> 是 HTTP / 1.0 的产物，表示资源会在 <code>Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。并且 <code>Expires</code> 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p> <div class="language-js extra-class"><pre class="language-js"><code>Cache<span class="token operator">-</span>control<span class="token punctuation">:</span> max<span class="token operator">-</span>age<span class="token operator">=</span><span class="token number">30</span>
</code></pre></div><p><code>Cache-Control</code> 出现于 HTTP / 1.1，优先级高于 <code>Expires</code> 。该属性表示资源会在 30 秒后过期，需要再次请求。</p> <h4 id="协商缓存"><a href="#协商缓存" aria-hidden="true" class="header-anchor">#</a> 协商缓存</h4> <p>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。</p> <p>协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。</p> <h5 id="last-modified-和-if-modified-since"><a href="#last-modified-和-if-modified-since" aria-hidden="true" class="header-anchor">#</a> Last-Modified 和 If-Modified-Since</h5> <p><code>Last-Modified</code> 表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified</code> 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。</p> <p>但是如果在本地打开缓存文件，就会造成 <code>Last-Modified</code> 被修改，所以在 HTTP / 1.1 出现了 <code>ETag</code> 。</p> <h5 id="etag-和-if-none-match"><a href="#etag-和-if-none-match" aria-hidden="true" class="header-anchor">#</a> ETag 和 If-None-Match</h5> <p><code>ETag</code> 类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code> 发送给服务器，询问该资源 <code>ETag</code> 是否变动，有变动的话就将新的资源发送回来。并且 <code>ETag</code> 优先级比 <code>Last-Modified</code> 高。</p> <h4 id="选择合适的缓存策略"><a href="#选择合适的缓存策略" aria-hidden="true" class="header-anchor">#</a> 选择合适的缓存策略</h4> <p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p> <ul><li>对于某些不需要缓存的资源，可以使用 <code>Cache-control: no-store</code> ，表示该资源不需要缓存</li> <li>对于频繁变动的资源，可以使用 <code>Cache-Control: no-cache</code> 并配合 <code>ETag</code> 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li> <li>对于代码文件来说，通常使用 <code>Cache-Control: max-age=31536000</code> 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li></ul> <h3 id="使用-http-2-0"><a href="#使用-http-2-0" aria-hidden="true" class="header-anchor">#</a> 使用 HTTP / 2.0</h3> <p>因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。</p> <p>在  HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。</p> <h3 id="预加载"><a href="#预加载" aria-hidden="true" class="header-anchor">#</a> 预加载</h3> <p>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。</p> <p>预加载其实是声明式的 <code>fetch</code> ，强制浏览器请求资源，并且不会阻塞 <code>onload</code> 事件，可以使用以下代码开启预加载</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>http://example.com<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</p> <h3 id="预渲染"><a href="#预渲染" aria-hidden="true" class="header-anchor">#</a> 预渲染</h3> <p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>prerender<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>http://example.com<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> 
</code></pre></div><p>预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染</p> <h2 id="pwa-离线缓存"><a href="#pwa-离线缓存" aria-hidden="true" class="header-anchor">#</a> PWA 离线缓存</h2> <h3 id="主线程"><a href="#主线程" aria-hidden="true" class="header-anchor">#</a> 主线程</h3> <p><code>ServiceWorker</code>既然命名为<code>worker</code>，很大一部分原因就是它和<code>WebWorker</code>相关。它是第二个线程，不会影响 dom 渲染的主线程，两个<code>Worker</code>之间的通讯是基于<code>postMessage</code>。
<code>chrome://inspect/#service-workers</code> 就可以查看，在当前浏览器中，正在注册的 <code>SW</code>。另外，还有一个 <code>chrome://serviceworker-internals</code>，用来查看当前浏览器中，所有注册好的 <code>SW</code>。</p> <h3 id="基于-https"><a href="#基于-https" aria-hidden="true" class="header-anchor">#</a> 基于 HTTPS</h3> <p><code>SW</code> 是基于 <code>HTTPS</code> 的，如果你的网站不是 <code>HTTPS</code>，那么基本上你也别想了 <code>SW</code>。</p> <h3 id="scope-作用域"><a href="#scope-作用域" aria-hidden="true" class="header-anchor">#</a> Scope 作用域</h3> <p>一个<code>sw.js</code>并不能接管一个站点所有的页面，它只能在所在路由底下起到作用。意思就是如果你在<code>//example.com/foo/bar.js</code>里注册了一个 <code>SW</code>，那么它默认的作用域为<code>//example.com/foo/</code>。</p> <h3 id="生命周期"><a href="#生命周期" aria-hidden="true" class="header-anchor">#</a> 生命周期</h3> <h4 id="register"><a href="#register" aria-hidden="true" class="header-anchor">#</a> register</h4> <p><code>ServiceWorker.js</code>(又名<code>sw.js</code>)是一个独立 js，页面注册在浏览器支持的情况下，注册 sw.js 来控制<code>Service Worker</code>缓存。<code>register</code>将会触发安装声明周期。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'serviceWorker'</span> <span class="token keyword">in</span> navigator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  navigator<span class="token punctuation">.</span>serviceWorker
    <span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'/sw.js'</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>registration<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>
        <span class="token string">'ServiceWorker registration successful with scope: '</span><span class="token punctuation">,</span>
        registration<span class="token punctuation">.</span>scope
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'ServiceWorker registration failed: '</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="install"><a href="#install" aria-hidden="true" class="header-anchor">#</a> install</h4> <p><code>register</code>完成后会触发<code>install</code>的生命周期，把设置好的静态文件，采用<code>Service Worker</code>的缓存方式，使用了<code>Cache API</code>来将资源缓存起来，同时使用 <code>e.waitUntil</code> 接手一个<code>Promise</code>来等待资源缓存成功，等到这个<code>Promise</code>状态成功后，<code>ServiceWorker</code>进入<code>installed</code>状态，意味着安装完毕。这时候主线程中返回的<code>registration.waiting</code>属性代表进入<code>installed</code>状态的<code>ServiceWorker</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token constant">CACHE_NAME</span> <span class="token operator">=</span> <span class="token string">'my_cache'</span>
<span class="token keyword">var</span> urlsToCache <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'/index.html'</span><span class="token punctuation">,</span> <span class="token string">'/css/style.css'</span><span class="token punctuation">,</span> <span class="token string">'/js/script.js'</span><span class="token punctuation">]</span>
<span class="token comment">//这里的self代表ServiceWorkerGlobalScope</span>
self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'install'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//这里的waitUtil会在安装成功之前执行一些预装的操作，但是只建议做一些轻量级和非常重要资源的缓存，减少安装失败的概率。安装成功</span>
  <span class="token comment">//后ServiceWorker状态会从installing变为installed</span>
  event<span class="token punctuation">.</span><span class="token function">waitUntil</span><span class="token punctuation">(</span>
    caches<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token constant">CACHE_NAME</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Opendhe : '</span><span class="token punctuation">,</span> cache<span class="token punctuation">)</span>
      <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>urlsToCache<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="skipwaiting"><a href="#skipwaiting" aria-hidden="true" class="header-anchor">#</a> skipWaiting</h4> <p><code>skipWaiting()</code>意味着新 <code>SW</code> 控制了之前用旧 <code>SW</code> 获取的页面，也就是说你的页面有一部分资源是通过旧 <code>SW</code> 获取，剩下一部分是通过新 <code>SW</code> 获取.</p> <h4 id="activate"><a href="#activate" aria-hidden="true" class="header-anchor">#</a> activate</h4> <p>安装完，则会进入激活状态。如果之前已有<code>ServiceWorker</code>，这个版本只是对<code>ServiceWorker</code>进行了更新。如果你在<code>event.waitUntil()</code>中传入了一个 <code>Promise</code>，<code>SW</code> 将会缓存住功能性事件(<code>fetch</code>,<code>push</code>,<code>sync</code>等等)，直到 <code>Promise</code> 返回 <code>resolve</code> 的时候再触发，也就是说，当你的<code>fetch</code>事件被触发的时候，<code>SW</code> 已经被完全激活了。</p> <div class="language-js extra-class"><pre class="language-js"><code>self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'activate'</span><span class="token punctuation">,</span> event <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  event<span class="token punctuation">.</span><span class="token function">waitUntil</span><span class="token punctuation">(</span>
    caches<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>keys <span class="token operator">=&gt;</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>
      keys<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>key <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>expectedCaches<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> caches<span class="token punctuation">.</span><span class="token keyword">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// V2控制缓存</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="fetch"><a href="#fetch" aria-hidden="true" class="header-anchor">#</a> fetch</h4> <p><code>fetch</code>请求是有别于<code>xhr</code>请求，<code>sw</code>提供监听拦截<code>fetch</code>的事件，对于命中缓存的数据可以直接返回请求。当接受到 <code>fetch</code> 请求时，会直接返回<code>event.respondWith</code> 得到<code>Promise</code> 结果。这样我们可以捕获页面所有的 <code>fetch</code> 请求。</p> <div class="language-js extra-class"><pre class="language-js"><code>self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'fetch'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  event<span class="token punctuation">.</span><span class="token function">respondWith</span><span class="token punctuation">(</span>
    caches<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>request<span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Cache hit - return response</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> response<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="redundant"><a href="#redundant" aria-hidden="true" class="header-anchor">#</a> Redundant</h4> <p><code>Service Worker</code> 可能因为以下之一的原因而被废弃（redundant，原意为“多余的，累赘的”）</p> <ul><li><code>installing</code> 事件失败</li> <li><code>activating</code> 事件失败</li> <li>新的 <code>Service Worker</code> 替换其成为激活态 <code>worker</code></li></ul> <p>浏览器获取了新版本的<code>ServiceWorker</code>代码，如果浏览器本身对<code>sw.js</code>进行缓存的话，也不会得到最新代码，所有代码会变成死代码，无法更新。所以对<code>sw</code>文件最好配置成<code>cache-control: no-cache</code>。</p> <h2 id="优化渲染过程"><a href="#优化渲染过程" aria-hidden="true" class="header-anchor">#</a> 优化渲染过程</h2> <h3 id="懒执行"><a href="#懒执行" aria-hidden="true" class="header-anchor">#</a> 懒执行</h3> <p>懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。</p> <h3 id="懒加载"><a href="#懒加载" aria-hidden="true" class="header-anchor">#</a> 懒加载</h3> <p>懒加载就是将不关键的资源延后加载。
懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。</p> <p>将页面里所有 img 属性 src 属性用 data-xx 代替，当页面滚动直至此图片出现在可视区域时，用 js 取到该图片的 data-xx 的值赋给 src，这样图片就会去下载资源，实现了图片懒加载。</p> <p>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。</p> <div class="language- extra-class"><pre class="language-text"><code>页可见区域宽： document.body.clientWidth;
网页可见区域高： document.body.clientHeight;
网页可见区域宽： document.body.offsetWidth (包括边线的宽);
网页可见区域高： document.body.offsetHeight (包括边线的宽);
网页正文全文宽： document.body.scrollWidth;
网页正文全文高： document.body.scrollHeight;
网页被卷去的高： document.body.scrollTop;
网页被卷去的左： document.body.scrollLeft;
网页正文部分上： window.screenTop;
网页正文部分左： window.screenLeft;
屏幕分辨率的高： window.screen.height;
屏幕分辨率的宽： window.screen.width;
屏幕可用工作区高度： window.screen.availHeight;
</code></pre></div><h2 id="文件优化"><a href="#文件优化" aria-hidden="true" class="header-anchor">#</a> 文件优化</h2> <h3 id="图片优化"><a href="#图片优化" aria-hidden="true" class="header-anchor">#</a> 图片优化</h3> <h4 id="计算图片大小"><a href="#计算图片大小" aria-hidden="true" class="header-anchor">#</a> 计算图片大小</h4> <p>对于一张 100 * 100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1个字节），所以该图片大小大概为 39KB（10000 * 1 * 4 / 1024）。</p> <p>但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。</p> <p>了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了：</p> <ul><li>减少像素点</li> <li>减少每个像素点能够显示的颜色</li></ul> <h4 id="图片加载优化"><a href="#图片加载优化" aria-hidden="true" class="header-anchor">#</a> 图片加载优化</h4> <ol><li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</li> <li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li> <li>小图使用 base64 格式</li> <li>将多个图标文件整合到一张图片中（雪碧图）</li> <li>选择正确的图片格式：
<ul><li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li> <li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li> <li>照片使用 JPEG</li></ul></li></ol> <h3 id="其他文件优化"><a href="#其他文件优化" aria-hidden="true" class="header-anchor">#</a> 其他文件优化</h3> <ul><li>CSS 文件放在 <code>head</code> 中</li> <li>服务端开启文件压缩功能</li> <li>将 <code>script</code> 标签放在 <code>body</code> 底部，因为 JS 文件执行会阻塞渲染。当然也可以把 <code>script</code> 标签放在任意位置然后加上 <code>defer</code> ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 <code>async</code> ，表示加载和渲染后续文档元素的过程将和  JS 文件的加载与执行并行无序进行。</li> <li>执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 <code>Webworker</code>。<code>Webworker</code> 可以让我们另开一个线程执行脚本而不影响渲染。</li></ul> <h3 id="cdn"><a href="#cdn" aria-hidden="true" class="header-anchor">#</a> CDN</h3> <p>静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。</p></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/ViktorWong/Full-Stack-Library/edit/master/docs/Js/Performance.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/Full-Stack-Library/Js/Coding.html" class="prev">
          代码重构经验
        </a></span> <!----></p></div> </div> <!----></div></div>
    <script src="/Full-Stack-Library/assets/js/app.4ce4532c.js" defer></script><script src="/Full-Stack-Library/assets/js/15.ed466076.js" defer></script>
  </body>
</html>
